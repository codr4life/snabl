* drop LambdaPtr/FimpPtr/TargetPtr
** store lambdas by value
** replace call.target with variant<Fimp *, Lambda>
* add IO enum
** Lib::add_enum(env.sym("IO"), {env.Sym("r"), env.Sym("w"), env.Sym("rw")})
** enum: IO (r w rw)
** generate io: macro
*** io:r, io:w, io:rw
** push specified sym with enum type
** add fopen mode
** add w/rw support to fopen
* add bool conversion to if:
** add Bool op
* add or: macro
** get first operand from stack
** treat body forms as multiple operands
* add and: macro
** like or:
* add include: macro
** one arg
** load all files into ops
** add bench/all.sl
* add while: loop
** like times
* add for: loop
** Iter ... IterNext
** keep iter in Iter op
** step and jump to start in IterNext
* eval fimps at compile time
** <3 times: Int>
** begin/end_scope
** use stack as args
* add derived methods
** switch type methods to lambdas
** leave nulled and check in Box
** copy methods on derive
* add define: macro
** like let but bind at runtime
** add lib.consts
** @ sigil
* add support for str special chars
* add support for func/fimp refs with &
** add func/fimp type
* add Ref support
** add bench/fib3.sl
* add Pair type
** use std::pair<Box, Box>
* implement push for sinks
** Str
* implement peek/pop for sources
** Str/Iter
* add alias: Foo Int macro
** allow aliasing funcs/fimps/types
** enable macro processing for all ids
* add type: Foo Int macro
** derive new type from parent
** generate constructor 

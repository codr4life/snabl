* remove dummy let:/if:/switch: arg
** use whatever is on stack
* switch _pc fields to ssize_t
** ops/fimp/lambda
** init to -1

* eval fimps at compile time
** use stack as args
* move main scope into Task
* ---
* move scope ptr into Task
* move stack/splits into Task
* move _lib ptr into Task
* move _try ptr into Task
* add task: macro
** run ops in separate task
** capture parent scope like fimp/lambda
* add for: loop
** Iter ... IterNext
** keep iter in Iter op
** step and jump to start in IterNext
* add bench: macro
** replaces fn
** use For/Next
*** Box(env.int_type, n).iter()
** add Timer op
** add TimerPush op
*** push current time and reset
* add stack bench
** push/pop range of ints
** wrap each int in nested stack/list
* remove call now arg
* add support for str special chars
* add Type.clone
** push clone of arg
** clone pushed values in Push/Get ops
* add include: macro
** one arg
** load all files into ops
** add bench/all.sl
* add support for func/fimp refs with &
** add func/fimp type
* add Pair type
** use std::pair<Box, Box>
* add type: Foo Int macro
** derive new type from parent
** generate constructor 
* add trait: Foo (Bar Baz) macro
** derive children from type

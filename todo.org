* rename Type.is_true to as_bool
* add push<Sink> fn
* add pop<Source> fn
* add splat
** 3.. => [0 1 2]
* add stash
** [..] => [[0 1 2]]
** [1..] => [[1 2]]
** [..2] => [[0 1]]
* add split
** 1 2 | 3 4 [..] => [1 2 [3 4]]
** add env.splits
** active until end of expression
** add env.stack_size() const
*** adapt peek/pop
*** adapt all stack ops
* add for: loop
** Iter For ... Next
** alloc iter in op like Try.state
** For takes Iter op as arg
** Next takes For op as arg and jumps if more
* add stack bench
** push/pop range of ints
** wrap each int in nested stack/list
* add Type.clone
** push clone of arg
** clone pushed values in Push/Get ops
* add Quote form
** contain quoted like Query
** push quoted ids as syms
** push quoted literals as is
* change forms::TypeList to contain form like Query
** rename to Fimp
** remove no_type
*** map _ to Maybe instead
* add rewrite fence after if: and switch: when needed
** use ops::Nop
* add include: macro
** one arg
** load all files into ops
** add bench/all.sl
* add Str literal support
** ''\'foo''
* add [] indexing support
** parse as func '[]' and call with args
* add support for func/fimp refs with &
** add func/fimp type
* add use: macro
* add lib: macro
** two args, id & body
** allow anonymous, _
*** push anonymous libs in current scope
*** add lib op which contains the actual lib
*** use for local defs
* add load func
** call when called with args
* add push ddrop rewrite
** pop two ops and compile drop

vmacro: (drop drop) (ddrop 'ddrop)
vmacro: (rot swap) (ddrop 'rswap)
vmacro: (swap drop) (ddrop 'sdrop)
vmacro: (dup drop) ddrop
vmacro: (dup ddrop) (ddrop 'drop)
vmacro: (get drop) ddrop
vmacro: (get ddrop) (ddrop 'drop)
vmacro: (lambda drop) ddrop
vmacro: (lambda ddrop) (ddrop 'drop)
vmacro: (push drop) ddrop
vmacro: (push ddrop) (ddrop 'drop)

snax
Snabl as a service

* make Eqval.val optional
** pop both vals if null
** emit Eqval with null val by default
* replace Box.val with static space
** add const MAX_SIZE;
** static cast in as()
*** return const ref
* add Slab<SIZE> class
** put in front of Alloc
** take as constructor param
** replaces destructor
* add Realloc<T> class
** use Slab in front
** add free list
* change switch: to take two args
** check second is forms::Comma/Semi/Sexpr
*** treat as Body
* add Fimp closure like Lambda
* add rewrite fence after if: and switch: when needed
** use ops::Nop
* add if-else func
** use in fib1/2 and compare perf
* check snabl fimp results
* add support for func/fimp refs with &
** add func/fimp type
* add Str literal support
** 'foo\''
* add Source
** add pop fn
* add Sink
** add push fn
* add Stack
** use vector imp
* add Seq/Iter
** add for fn
* add [] indexing support
** parse as func '[]' and call with args
* add use: macro
* add lib: macro
** two args, id & body
** allow anonymous, _
*** push anonymous libs in current scope
*** add lib op which contains the actual lib
*** use for local defs
* add load func
** call when called with args
* add sqlite plugin
* add wxwidgets plugin

func: fib<Int Int Int> Int (
  let: (n a b) _
  switch: @n z? @a one? @b, --; @b dup @a +; recall
)

func: fib<Int Int Int> Int (
  let: (n a b) _
  if: (z? @n) @a, if: (one? @n) @b, @n --; @b dup @a +; recall
)

func: fib<Int Int Int> Int (
	rswap dup
  if: z?
    (drop sdrop),
    dup if: one? ddrop, --; rswap dup rot +; recall
)
